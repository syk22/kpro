# B 問題

仕切り直し（2024/08/29〜）

目標 20 分以内 -> 最初は時間を気にしない

あまりにもできないので、2回目は10問ずつで行う  
-> 300, 360番台を経て、できるようにもなってきてだいぶ慣れてきた気もするので、5分越えの問題を目安に2回目を実施に切り替える

## 各問題所感

<details>
<summary>300番台</summary>

### 300

1:  
いきなり1時間以上考えてもわからないの来たw  
回答を見た。考え方は合ってたけど実装がよくわからなかったので確認

2:  
・ずらす数(s,t)の方が外側、インデックス(i, j)は内側  
　そうでないと内側のループでずらした状態を確認できない  
・`インデックス - 足した数 + MAX項数 or 行数` ではMAX項数 or 行数✖️2までしか見れない  
　`インデックス - 足した数 + MAX項数 or 行数` にMAX項数 or 行数で割ったあまりをインデックスとするとうまくいく

この基本がわかっていないのでまたまた時間を食ってしまった。。。

### 301

1:  
とにかく丁寧に解いたところうまく行った  
B問題はとにかく丁寧、これでいこう

2:  
特にいうことはないけど、もうちょっと早くしたいな、  
と思ったけど、1回目より若干早かったからまあよし

### 302

1:  
１方向に対するアプローチをうまく書けたかな

2:  
解説見ながらもっと全探索 && もっと簡潔な書き方を学ぶ

- xとyの方向をバラすのはアリ  
- 進んだ先のインデックスを変数化する。いちいち`i + dy[d] * k`とか書かない  
- 一番内側のループで範囲外を感知、範囲外なら終了させる  
- 一度全ての文字列を取得させる→特定パターンだった時のみ出力させる  

などなど、学びは多かった。もう一回やろう。


### 303

1:  
私の回答：  
各人の配列の中に、相手の配列を作り、隣り合っていたかどうかをチェックした  
-> 隣り合っていない個数を数え上げる

解説：  
全ての組(x, y)が隣り合っているかを数え上げる

`.at(i)` だと逆にわかりにくいかな。。。。`[i]` で書こうかどうしようか

2:  
同じように作成、でも実装にすごい時間がかかってしまう  
解説の通りに数え上げていったらとても楽にできた

条件分岐しないで済むものは、極力配列を確認しながら処理をする
数え上げ系はその内容を重視しているわけではないことを覚える

→実際の配列のインデックスは内側、条件に合致しない場合はフラグを外す、等、できなかった実装ができているので上達はしている。はず。

### 304

1:  
全ケース書き出す必要がなく、for文で書けたのはよかった

2:  
同じくかけた。これは大丈夫そう。

### 305

1:  
char型の数値変換は問題なし  
基本ロジックは問題なさそうなのにflagを１ループごとに初期化させるようにして悩んでしまった。。。。

2:  
前回引っかかったところは全てパスして成功！バンザイ！！

### 306

1:
bitきたー

2:
bitのやり方は覚えていたので問題なし  
ただ、下記のような場合は `ans` だけではなく `A` も `unsigned long long` にしておく必要があることは知らなかったなあ。。。。

```
for (int i = 0; i < 64; i++) {
  cin >> A;
  ans += A << i
}
```

でもよくよく考えると下記の場合でintで出力されるのと同じことか。。。

```
int A = 7;
double B = 2;

cout << A / B << endl;
```

### 307

1:  
解説一瞬見た時のi ≠ jに気付かされた  
それ以外にもSTを足し上げていたりだとか、色々勘違いをしていた

実装しながらではなくて、実装する前に考えたほうがいいのかな

2:  
覚えていたので問題なし

### 308

1:  
落ち着いてやればOK

2:  
これも落ち着いてやれた。

### 309

1:  
解説みた  
-> 数字が分解されていないものは文字列として受け取って処理するほうが楽
　その上で外側のますがどうやって動くかを考えて書いていく

これも落ち着いてやること  
B問題はとにかく落ち着くこと、ロジックは分かっているのでそれを忠実に再現すること

2:  
解説通りに解けた。  
あとは、サイズNの文字列をスマートに作れればいいんだけど、いい関数はないものか

-> `string S(N, 'X');` でいいらしい!!

</details>

<details>
<summary>330番台</summary>

### 330

1:  
中央値を求める問題  
中央値がLとRの間の数でなければLとRの近い方を指す  
たまたまそんな関数があるってどこかで見たから解けたけど、、、

これもこういうもの、と覚えておかないといけない問題だなあ

### 331

1:  
ザ・全探索  
とはいえ、100全部探すのか、、、

+2ではなく、+3まで探索範囲にすればWAではなかったのか、、、、悔しい

### 332

1:  
そのまま実装すればOK  
もっと早くできる気もするけど、よく解けた

### 333

1:  
アルゴリズムを考えるのに時間がかかったけど、できて多分良かった  
別解が面白かった。これで回答してもいいかもしれない

### 334

1:  
地点系の問題は難しい！
まず、座標の中心をAにすることで簡便化する  
それから、進む座標の計算をする

ここで書いててもあまり良くなさそう、ノートにまとめたい

### 335

1:  
その前までがめちゃくちゃ難しかったんで、すごく気が抜けた

### 336

1:  
これの応用が372B  
2で割ってあまりが出ない数を出せばOK、と気づけただけでも偉い。

### 337

1:  
ABCのどれかしかないからできたが、もっときちんと `-'A'` で数値をしっかり入力すべきだったかな

### 338

1:  


</details>

<details>
<summary>340番台</summary>

### 340

1:  
特に問題なし

### 341

解説見ながらint->llにすればOKだったことを知る、、、、  
10^9 はllにしないといけないんでしたね。。。  
`2^8(2,147,483,647) < 10^9(10,000,000,000)`

### 342

1:  
頭がふわふわした状態で始めたため、本当にこれでいいのか？？？と疑問に思いつつの進み方になってしまった

### 343

1:  
問題が理解できておらず、ぼんやりする時間が入ってしまった、、、

### 344

1:  
なんかやっぱり頭がふわふわしているまま解いている印象  
結論：肉体的に疲れている日は頭も回らない

### 345

1:  
言語仕様の問題？
なんか、とある小数点以上の最長の整数値取得する関数がある気がする  
`(X + 9) / 10` -> `(a + b - 1) / b`  この式だ。忘れる。。

### 346

1:  
あまりにもできないので解説を見た。  
ある特定の、でも連続して出てくる文字列を探すとき、配列の文字数で割ったあまりをインデックスに使う方法なあ。忘れてた。  
345, 346どちらもこのあと使うであろうテクニックが詰まっているなあ。。。

### 347

1:  
setを使って難なく解けた

### 348

1:  
もうユークリッド距離、間違えないぞう  
とはいえ、距離を求めたらそのまま距離の最大値を確認しておけば良かった  
インデックス番号も取得するまでは頭が回ったのにねえ。

### 349

1:  
解説見ても解答アルゴリズムが同じなのにWAが出て混乱  
最終的には、本来101まで見なければならない配列に対して26しか見てなかった。そりゃ間違えるわ

やっぱり今日はボケボケだった  
肉体疲労は脳に影響する・・・・

</details>

<details>
<summary>350番台</summary>

### 350

1:  
問題なく終了。360番台が全然できない問題ばっかりだったので少しホッとした

### 351

1:  
難なく解答

### 352

1:  
時間がかかってしまったけれど、基本の方針に問題はなし  
→SとTそれぞれのインデックスを見ることにする

2:  
焦りすぎて必要な変数宣言まで消してCEになってしまった  
これがなければ5分切れていたな。。。

### 353

1:  
時間はかかったけど、なんとか解けた。

2:  
while入れないとなあ、というのはわかるけどやっぱりわからんw  
難しいなあ。。。

### 354

1:  
最初、またMapを作ろうとしたが、Map作らずとも行けることが途中で分かったので、作り直しをした。  
時間はかかってしまったけれど、それでも最後はきちっと解けたのでよしとする。

2:  
Mapは作らないぞ、という頭で行ったので早かった  
初見でも判断できるようになりたい

### 355

1:  
大体B問題で要求されるレベルが把握できるようになってきた気がする。  
同時に、それにアジャストすることもできるようになってきた気がする

2:  
最初より時間がかかってしまった  
AとBで見るものを逆にしてしまっていた、、、、

### 356

1:  
解くことはできるな、という自信はついてきた

2:  
この問題は特にいうことなし

### 357

1:  
解く方針は間違っていないけど、プラスとマイナスがよく分かっていなかった。。。  
もう少し早く解けたはずなのに

2:  
早く解けたけれども、  
`for (auto &i : a) cout << i;` の形で文字列を書き出そうとするとうまくいかないので注意

### 358

1:  
これも特にいうことなし  
けど、冷静に考えるとわざわざTを配列化する必要はなかったかな

2:  
焦ってしまってよくわからないことをやってしまった

### 359

1:  
特にいうことなし

</details>

<details>
<summary>360番台</summary>

### 360

1:  
問題文を理解することができない。。。。

2:  
やっぱり問題文を理解できていないので、時間がかかった。  
もう少し細かいところまで理解できるようになりたいな、図解がいるかな

### 361

1:  
立体図形は無理、ということであっさり解説を確認。  
なるほどね、一定区間との共通部分を確認することでいけると。

2:  
x, y, z 座標全ての共通部分がある場合はYes、ということがわかっておらず、立式で失敗  
あと、外部関数化もよくわかっていなかった

### 362

1:  
三平方の定理！傾きが-1になるところを探す、みたいに難しく考えすぎていた

2:  
三平方の定理であることがつかめればそんなに苦労はしない

### 363

1:  
日付のカウントと何人いるかのカウントを別に考える必要があるのにごっちゃになってしまった  
あと、カウントした後にループを抜けるか判断してから日を増やすこの順番が大事  
そこは一部失敗したけどまあまあできているかな

ここ何回か、先にwhileの中身の処理を書いた後にwhileで囲むやり方をしているのだけど、その方が焦らないかも

2:  
条件がごっちゃになってしまったけれども、うまくいったんじゃないかと思っている  
とはいえ、時間が1回目よりかかっているのでもう一回かな。。。

### 364

1:  
盤面系は動く方向を足してやる方法でうまくいきそう  
あとはどうやってスピードを上げるかかな、、、、

2: 
設計はうまくいっていたが、三項演算子で失敗していたな。。。  
これは何度かやって慣れていこう

### 365

1:  
`sort(x.rbegin(), x.rend());` もテンプレに入れた方がいいな。。。。

2:  
特にいうことなし

### 366

1:  
最初のロジックは良かったけれども、不要な `*` をとるロジックがよくわからず解説確認  
そうか、もう一回見て、末尾が*なら取れば良かったのね

2:  
末尾を確認する方法、文字列の長さを取得してからその最後を確認すること

### 367

1:  
int と double の調整も上手くできたと思う  
でももう少しタイム縮められたかな！

2:  
何も考えずdouble型で処理するだけでOK  
ただし、いつもうまくいくとは限らない。文字列で取得し、末尾が`0`だった場合は削除するなどした方が確実

### 368

1:  
そこそこ時間がかかったけど、while文の抜け出しをきちんと書けるようになったところは自分としても評価していいと思う

2:  
前より若干早くなった  
先にしっかり条件確認しておけばもっと早くできたかな

### 369

1:  
落ち着いていけばOK

2:  
配列2つ目の要素から前の要素との差を確認する方がスマートだったな。。。。

</details>

## もっと練習（3回目）した方がいい問題

300, 302, 303, 306,  
  
353, 355, 358,  
360, 361 ,363, 366, 368, 369,  
372,

<details>
<summary>370番台</summary>

### 370

1:  
26分越えで攻略

とはいえ夜中の回らない頭じゃこれが限界寧ろよくやったっしょ

### 371

1:  
これ絶対6分切れたな  
A問題のJiroより簡単だった。。。。

### 372

1:  
しばらく理解できなかったなあ、、、  
ある程度「こういうもの」と覚えるしかないものかも

</details>
