# C 問題

以前はやらなかったC問題スタート

1. 目標 ~解けること~ まずは解き方を覚えていく

多分あまりにも解けないと思われるので、アルゴ式や本で勉強しないといけなさそう  
とりあえず10-20問程度やってみて、感触を掴む

## 各問題所感

<details>
<summary>360番台</summary>

### 360


### 361


### 362


### 363


### 364


### 365


### 366


### 367


### 368


### 369


</details>

<details>
<summary>370番台</summary>

### 370

1:  
Sからひとつ変更したもののうち、どれが一番辞書別で速いかを比較する方法(N^3)  
Sの文字列のうち、先頭からTの方が若いものをインデックスしていく。その後、後ろからSの方が若いものをインデックスしていく。  
最後に、インデックスされた順にSの文字をTに入れ替えたものを表示すればOK(N^2)

やり直してできた。辞書順の発想、大事にしたい。

### 371

1:  
無向グラフの問題  
はっきり言って何言ってるかわからない！！！

-> 解説見ながらコーディング。ああなるほど。組み替えたものを全部書きだして探索するのね。。。。  
ついにnext_permutationを使う時が来てしまった

### 372

1:  
楽勝ォ〜と思ったけど、TLEになってしまった。  
C問題はベタに計算してはならない。必要部分でのみ計算することが重要。  
ちなみに今回は `2 * 10^5 * 2 * 10^5` なので実質 `4 * 10^10` の計算量をかけてしまった計算  
数値だけでなくて計算量を見る必要ね。。。

### 373

1:  
long long型の最小値は `LLONG_MIN` これ覚えておかないと、、、

### 374

1:  
順列の次はbit全探索。。。(wasureteruu)  
`for (int b = 0; b < (1 << N); ++b)` でN個のbit全探索が可能  
bitの1/0調べたいときは `if (b & (1 << i))` これで i 桁目が1かどうか調べられる

### 375

1:  
愚直にN^3の計算量では間に合わないので、それぞれのマスが何回変更になるのかを予め想定し、そのマス目によって変更する、、、、という方針  
けれども具体的にこの問題見ても、このマス目がどう変わるのかよくわかっていない。。。。

### 376

1:  
・ソートしてAとBを見比べる→そもそも同じインデックスなのにBの方が小さい時点でアウト  
・その後、Aのインデックスをひとつずらしてみて、最後にズレてるところが回答  
・ズレてるところがなかったら一番最初のA

なるほど、、、、  
２段構えの確認をするのね  
1回目の確認でないかどうかを見る、2回目の確認で違うところを見る、は大事な発想だなあ。

2分探索はやり方を見てようやく思い出した。あったねそういうの。

### 377

1:  
タイムアウトしないように計算量調節するの上手くいったかな  
C問題はタイムアウトしないようにする配慮が必要だな〜

### 378

1:  
タイムアウトしない実装を考えついたのはいいものの、こんな簡単で大丈夫なんだろうか  
あとmapの使い方、もう少し慣れたい

### 379

1:  


### 380

1:  
ロジックは簡単だったものの、実装が難しかったな。。。

</details>
