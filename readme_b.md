# B 問題

仕切り直し（2024／08/29〜）

目標 20 分以内 -> 最初は時間を気にしない

あまりにもできないので、2回目は10問ずつで行う（予定）

## 各問題所感

<details>
<summary>300番台</summary>

### 300

1:  
いきなり1時間以上考えてもわからないの来たw  
回答を見た。考え方は合ってたけど実装がよくわからなかったので確認

2:  
・ずらす数(s,t)の方が外側、インデックス(i, j)は内側  
　そうでないと内側のループでずらした状態を確認できない  
・`インデックス - 足した数 + MAX項数 or 行数` ではMAX項数 or 行数✖️2までしか見れない  
　`インデックス - 足した数 + MAX項数 or 行数` にMAX項数 or 行数で割ったあまりをインデックスとするとうまくいく

この基本がわかっていないのでまたまた時間を食ってしまった。。。

### 301

1:  
とにかく丁寧に解いたところうまく行った  
B問題はとにかく丁寧、これでいこう

2:  
特にいうことはないけど、もうちょっと早くしたいな、  
と思ったけど、1回目より若干早かったからまあよし

### 302

1:  
１方向に対するアプローチをうまく書けたかな

2:  
解説見ながらもっと全探索 && もっと簡潔な書き方を学ぶ

- xとyの方向をバラすのはアリ  
- 進んだ先のインデックスを変数化する。いちいち`i + dy[d] * k`とか書かない  
- 一番内側のループで範囲外を感知、範囲外なら終了させる  
- 一度全ての文字列を取得させる→特定パターンだった時のみ出力させる  

などなど、学びは多かった。もう一回やろう。


### 303

1:  
私の回答：  
各人の配列の中に、相手の配列を作り、隣り合っていたかどうかをチェックした  
-> 隣り合っていない個数を数え上げる

解説：  
全ての組(x, y)が隣り合っているかを数え上げる

`.at(i)` だと逆にわかりにくいかな。。。。`[i]` で書こうかどうしようか

2:  
同じように作成、でも実装にすごい時間がかかってしまう  
解説の通りに数え上げていったらとても楽にできた

条件分岐しないで済むものは、極力配列を確認しながら処理をする
数え上げ系はその内容を重視しているわけではないことを覚える

→実際の配列のインデックスは内側、条件に合致しない場合はフラグを外す、等、できなかった実装ができているので上達はしている。はず。

### 304

1:  
全ケース書き出す必要がなく、for文で書けたのはよかった

2:  
同じくかけた。これは大丈夫そう。

### 305

char型の数値変換は問題なし  
基本ロジックは問題なさそうなのにflagを１ループごとに初期化させるようにして悩んでしまった。。。。

### 306

bitきたー

### 307

解説一瞬見た時のi ≠ jに気付かされた  
それ以外にもSTを足し上げていたりだとか、色々勘違いをしていた

実装しながらではなくて、実装する前に考えたほうがいいのかな

### 308

落ち着いてやればOK


### 309

解説みた  
-> 数字が分解されていないものは文字列として受け取って処理するほうが楽
　その上で外側のますがどうやって動くかを考えて書いていく

これも落ち着いてやること  
B問題はとにかく落ち着くこと、ロジックは分かっているのでそれを忠実に再現すること

</details>

## もっと練習した方がいい問題

300, 302, 303, 

<details>
<summary>360番台</summary>

### 369

落ち着いていけばOK

</details>